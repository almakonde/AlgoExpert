def can_make_change(coins, target_sum, coin_count):
    # Базовый случай: достигнута целевая сумма
    if target_sum == 0:
        return True
    # Базовый случай: закончились монеты или превышено количество монет
    if not coins or coin_count <= 0:
        return False
    # Рекурсивный случай 1: используем текущую монету
    with_current_coin = can_make_change(coins, target_sum - coins[0], coin_count - 1)
    # Рекурсивный случай 2: пропускаем текущую монету
    without_current_coin = can_make_change(coins[1:], target_sum, coin_count)
    
    # Возвращаем результат (можно ли собрать сумму с учетом текущей монеты или без нее)
    return with_current_coin or without_current_coin

# Ввод данных от пользователя
target_sum = int(input("Введите искомую сумму в центах: "))
coin_count = int(input("Введите количество монет: "))

# Монеты номиналом 1, 5, 10 и 25 центов
available_coins = [1, 5, 10, 25]

# Проверка возможности собрать сумму
result = can_make_change(available_coins, target_sum, coin_count)

# Вывод результата
if result:
    print(f"Можно собрать {target_sum} центов при помощи {coin_count} монет.")
else:
    print(f"Нельзя собрать {target_sum} центов при помощи {coin_count} монет.")
#    with_current_coin:
#        coins: это список доступных монет.
#        target_sum - coins[0]: это новая целевая сумма, уменьшенная на номинал текущей монеты. Этот шаг моделирует ситуацию, когда мы включаем текущую монету в решение.
#        coin_count - 1: это уменьшенное количество доступных монет текущего номинала.
#        Этот вызов представляет собой попытку включить текущую монету в решение, и программа рекурсивно проверяет, можно ли достичь новой целевой суммы с уменьшенным количеством монет.

#    without_current_coin:
#        coins[1:]: это список монет без текущей монеты. Этот шаг моделирует ситуацию, когда мы пропускаем текущую монету.
 #       target_sum: это неизмененная целевая сумма.
 #       coin_count: это неизмененное количество доступных монет текущего номинала.
 #       Этот вызов представляет собой попытку пропустить текущую монету и рекурсивно проверить, можно ли достичь целевой суммы с оставшимися монетами.